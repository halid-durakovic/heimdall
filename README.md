<img align="left" src="https://avatars0.githubusercontent.com/u/7360948?v=3" />

&nbsp;Heimdall<br /><br />
=============

| Downloads | Version |
|-----------|---------|
| ![NuGet Total](https://img.shields.io/nuget/dt/Heimdall.svg) | ![NuGet Version](https://img.shields.io/nuget/v/Heimdall.svg) |

Easy to use HMAC Digest Authentication for WebAPI with various client implementations (C#, NodeJS and Browser versions)

##How it works

Let's first take a look at the component parts. Heimdall is broken up into two distinct logical parts, namely, `server` and `client`. 
Both create compatible signed messages using the the individual message representation for each request using certain key dimensions. 
So for example if we were to make a get request like the one below:

**Insecure GET Request**

A simple vanilla request with no authentication.

*Headers*
    
    Accept: */*
    Content-Type: application/json
    
*Path*
    
    GET /api/mysecureresource/1
  
You would require a `username` and a `secret` to sign the message, this is already implemented for you in a Heimdall C# and JavaScript
client which we will cover in more detail later on. Once the message is sent to the server a delegating handler will then verify the 
message and then decide whether it is valid or not. So if our username was 'username' and the secret was 'secret' then our example
request would now look something like this: 

**Heimdall GET Request**

A request generated by a Heimdall client.

*Headers*
    
    Accept: */*
    Content-Type: application/json
    X-ApiAuth-Username: username
    X-ApiAuth-Date: Thu, 23 Jul 2015 10:48:42 GMT
    Authorization: ApiAuth CLcQbLlK3HajC/PPpwwxLoqHCnCrlM1VBjN8TGnYjuM=
    
*Path*
    
    GET /api/mysecureresource/1
  
Here you can see how Heimdall calculates an authorisation hash using the message representation and adds additional headers so 
that the server can identify the user in order to rebuild the authorisation hash on the server. If these hashes match, then 
the request is allowed through, if not then a http response code 401 will be returned.

##Clients

There are 3 versions of clients that can be found in the `examples` folder of the source code for Heimdall. Let's take a look at
each one starting with the C# client first. 

###The C# Client

This client comes in two flavours. One that is Castle Windsor ready(for use with FluentWindsor) or one without. Use the latter if 
you are not using Castle Windsor as your IoC container. 

####Heimdall.Client

This is the non windsor version. Start by installing the `Heimdall.Client` NuGet. Once this is done let's look at how
you would make a simple signed get request using a HttpClient. 

```csharp
HttpClient client = HeimdallClientFactory.Create("myusername", "mysecret");
var content = new FormUrlEncodedContent(new[]
{
    new KeyValuePair<string, string>("firstName", "Alex"),
    new KeyValuePair<string, string>("lastName", "Brown")
});
var result = client.PostAsync("http://requestb.in/14nmm871", content).Result;
```

If you would like to see a working example of this, please see the console application .\examples\Example.Client after
opening the solution in Visual Studio. 

####Heimdal.Client.Windsor

Let's look at how we initialise a client using FluentWindsor. First start by installing the `Heimdall.Client.Windsor` NuGet. 
Next you would have to make sure that FluentWindsor is initialised(this should only be called once on startup).

```csharp
FluentWindsor.NewContainer(typeof(Program).Assembly).WithArrayResolver().WithInstallers().Create();
```

This will automatically pick up the `IWindsorInstaller` and install an instance of the `IHeimdallClientFactory` which can 
then be injected for consumption via any constructor known to the container. For demonstration purposes we are going to use
the ServiceLocator of FluentWindsor.

```csharp
var client = FluentWindsor.ServiceLocator.Resolve<IHeimdallClientFactory>().Create("username", "secret");
var content = new FormUrlEncodedContent(new[]
{
    new KeyValuePair<string, string>("firstName", "Alex"),
    new KeyValuePair<string, string>("lastName", "Brown")
});

var result = client.PostAsync("http://requestb.in/14nmm871", content).Result;
```

If you would like to see a working example of this, please see the console application .\examples\Example.Client.FluentWindsor 
after opening the solution in Visual Studio. 


